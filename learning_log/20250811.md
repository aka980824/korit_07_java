# Object 클래스
- 모든 클래스는 Object 클래스를 상속 받는다. 그래서 interface를 implement 할 때나, 다른 sub
클래스를 만들어서 extends 명령어를 통해 입력했을 때 우리가 직접 만든 슈퍼 class이외에 tostring()
를 하는 것 등이 있었습니다.
  1. toString() : 기본적으로 모든 class는 Object 클래스를 상속 받아, 클래스 이름과 해시코드(일종의 주소지 개념)
    을 return함.
     - 이를 Override하여 재정의 후 클래스의 정보를 출력 할 때 사용
     - ObjectTset/ ObjectTestMain 클래스작성을 예시로 볼수있음
     - 필드를 정의하고, toString() 메서드를 override하여, 필요한 필드를 출력
    -> Main 단계에서 특정 객체의 이름만으로도 출력이가능함.(sout(객체명);으로 가능해짐) showinfo()안써도됨
  2. equals() : 두 객체가 '논리적'으로 같은지를 비교하는 메서드(주소지의 차이가 아니라). 기본적으로
   object 클래스의 equals()메서드는 두 객체의 참조 주소를 비교합니다.
     - 형식 : 객체명1.equals(객체명2) > 객체명1과 객체명2의 참조주소가 동일한지 확인하여. -3 형식 문장으로 해석하면됨
        SVO.
  3. hashCode() : 객체를 정수값(hash 값)으로 변환(16진수가 아님). 해시 값은 주로 해시 기반 컬렉션에서 사용(추후 수업 예정)
     - equals() 메서드를 재정의시, 반드시 hashcode() 메서드도 재정의애햐만 합니다. 이유는 동일한 객체
       (equals == true) 는 동일한 해시 코드를 가져야하기 때문인데, 문제는 해시 코드가 같다고 해서 equals()가
        true가 아닌 경우가 있음

# Lombok
1. 설치법 -> 메뉴바 -> 설정 -> 좌측에 플러그인 -> lombok -> 설치후 적용
    -> chrome에서 maven repositories로 들어가 lombok 검색후 최신버전 클릭하여
    -> 저희는 빌드 시스템이 gradle이기 때문에, groovy short로 복사
```declarative
    dependencies {
    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
    implementation 'org.projectlombok:lombok:1.18.38'
    annotationProcessor 'org.projectlombok:lombok:1.18.38'
} 
```
이상과 같이, 작성되어야함.
# lombok 주요 annotation
1. @Getter/@Setter
    - class level에 작성의 경우 getter/setter 자동 생성
    - field level에 작성후 해당 필드에서만 메서드 생성
```java
@Getter
@Setter
public class Person{
    private String name;
    private int age;
} //로하면 getter/setter 할필요가 없음
```
2. @ToString
   - toString() 메서드를 자동으로 생성. 문제는 재정의가 안되고, lombok 라이브러리에서 default 형태로만 나오기 때문에,
   결과적으로 원하는 부분만 보여주기 위해서는 override methoods(alt + ins)를 쓰는 경우가 있어
   사용성이 떨어짐

3. @EqualsAndHashCode
    - equals() / hashCode() 메서드를 자동 생성. 객체의 동일성 비교 로직 구현시 사용
    - 아까 배웠던 것처럼 equals() 를 재정의시, hashCode() 도 반드시 같이 재정의해야하기 때문에, 애너테이션도
    세트로 묶여있음

4. @NoArgsConstructor /@RequiredArgsConstructor / @AllArgsConstructor
    - @NoArgsConstructor : argument가 없는 기본 생성자 생성
    - @RequiredArgsConstructor : final 또는 '@NonNULL' 에너테이션이 붙은 필드만 필수적으로 요구하는 매개변수 생성자를 생성
    - @AllArgsConstructor : 모든 필드를 argument로 요구하는 매개변수 생성자
```java
@NoargsConstructor
@RequiredArgsConstructor
@AllArgsConstructor
public class Person{
    @NonNULL
    private String name;
    private int age;
}
public class PersonMain(){
    public static void main(String[] args) {
        Person person1 = new Person(); // 기본생성자
        Person person2 = new Person("김이"); // name 을 요구하는 매개변수 생성자
        Person person3 = new Person("김삼",20); //@AllArgsConstructor
    }
}

```
5. @Data
   - @Getter/ @Setter/ @ToString/ @EqualsAndHashCode / @RequiredArgsConstructor

```java
import jdk.jfr.DataAmount;

@DataAmount
@NoArgsConstructor
@AllArgsConstructor
public class Person extends Person {
    private String name;
    private int age;
    private double score;
} //수강생들이 클래스만들때 제일 많이 하는 방식
```

6. @Builder - 추후 수업 예정