# Lambda Expression(람다식)
- Java 8에서 도입된 함수형 프로그래밍을 지원하기 위한 표현식 
* 형식

```java
// (매개변수) -> {실행문}
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("hello, java");
        }
    };
    runnable.run(); // hello, java 출력
}
```
이상의 익명 클래스 방식은 저희가 다룬적이 있는데,
Interface Runnable을 활용하여 임시적으로 run() 추상 메서드를 재정의하여
출력결과를 도출하는 형태였습니다.
```java
public static void main(String[] args) {
    Runnable runnable = () -> System.out.println("hello, java");
    
    runnable.run(); // hello, java출력
}
```
다음은 람다식을 적용한 이상의 코드

## 람다식의 등장 배경
- 람다식이 나오기 전에는 java에서 함수형 프로그맹을 하기 위해 익명 클래스를 이용(첫번째 예시코드)
- 허나 이러한 방식은 코드가 길어지고, 불필요한 반복이 많아져 가독성이 떨어지는 문제가 발생(call1()유형의 코드를 5개 정의한다고
하면, runnble1...runnable5까지 객채명을 다 지정해야함.

```java
import java.util.Comparator;

public static void main(String[] args) {
    Comparator<Integer> comparator = new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return 0;
        }
    }; // Compartor 인터페이스의 객체를 임의적으로 사용한 익명 클래스 예시
    
    Comparator<Integer> lambdaComparator = (o1,o2) -> o1.compareTo(o2);
    //이상의 코드로 요약 가능
}
```
## 람다식 장점
1. 코드 간결화 - 불필요한 코드제거로(Integer 반복이 없음), 가독성 향상
2. 표현력 향상 - 익명 클래스를 짧은 표현으로 대체
3. 지연 연산 - Stream API 와 함께 사용시, 지연 연산을 통해 성능 최적화

## 람다식 단점
1. 디버깅 어려움 - 람다식 내부에서 발생하는 오류디버깅이 힘듬
2. 재사용성 낮음 - 익명클래스에 '비해' 재사용이 어려움
3. 복잡한 로직 표현에 부적합 . - 단순 로직의 경우 람다식 사용, 아닌 경우 익명의 클래스 사용

## 람다식 문법
람다식 구조는 크게 3가지로 나뉨.
1. 매개변수 목록
2. 화살표 (->) : 그래서 js에서는 arrow expression 이라고 표현
3. 구현부/실행문(한국어판 intellij 에서는 메서드 본문)

```java
public static void main(String[] args) {
    // 1. 매개변수와 실행문이 하나 일 경우
    (int x,int y) -> x+y // 중괄호 생략가능 return 생략
    
    // 2. 매개변수가 하나일 때(소괄호 생략가능)
    str -> System.out.println(str); // call2() 유형
    
    // 3. 실행문이 여러 줄일 경우(중괄호 필수)
    (x,y) -> {
        //지역변수선언
        int sum = x+y;
        return sum;
    }
}

```

## 함수형 인터페이스 (Functional Interface)
- 람다식은 단일 메서드만 가지는 인터페이스(얘를 함수형 인터페이스라고 함) 를 구현하는 형태로
  `@FunctionalInterface` 애너테이션을 사용시 컴파일시에 단일 메서드인지 체크합니다
- 그래서 '시용자 정의 함수형 인터페이스'작성시 클래스 레벨에 `@FunctionalInterface` 를 명시

이유를 알 필요가 있음
인터페이스에 있는 메서드는 모두 '추상 메서드'입니다. -> 얘를 implement 받게 되면 추상 메서드를 강제로 구현해야 함

하지만 아까 call1()~ call4()까지의 유형을 하나의 객체에 강제 구현하게 될 경우, call3()만 필요한데 다른 나머지도 정의해야
한다는 문제점이 발생하기에, 각 유형 당 하나의 인터페이스/추상메서드만 존재하게 됐습니다.

```java
@FunctionalInterface
interface MyFunction{
    void start(); // 인터페이스 정의, 추상 메서드가 하나있음
}

public static void main(String[] args) {
    MyFunction myFunction = () -> System.out.println("정의된 함수를 실행합니다.");
    //매개변수가 아에 없을 경우 ()로 표시. 매개변수가 하나면 소괄호 생략
    
    myFunction.start();
}

```
## java에서 제공하는 주요 '함수형 인터페이스'
1. Runnable - void run(); - call()
2. Supplier - T get(); - call2()
3. Consumer - void accept(T t); - call2()
4. Function<T,R> - R apply(T t); - call3()
5. Predicate - boolean test(T t); -> 얘는 리턴 타입이 boolean고정이라 call1~call4로 분류하기 애매하지만,
굳이 따지면 call4()유형임 return true/false 중 하나이기에

## 함수형 인터페이스 별 상세
1. Runnable
- 매개변수 없고, 반환값도 없는 단순 실행을 위한 인터페이스
- 사용처 : 스레드 실행, 비동기 작업 실행
2. Supplier
- 매개변수 없이 값을 반환하는 인터페이스. 단순히 값을 '공급'
- 사용처 : 객체 생성, 자연 로딩
3. Consumer
- 값을 매개변수로 받아 사용하고, 아무값도 반환하지 않는 인터페이스 데이터를 '소비'하는 역할
- 사용처 : 데이터 처리,로깅 ,이벤트 핸들러
4. Function<T,R>
- '하나의 매개변수'를 받아서, 연산 수행후 결과값 출력
- 사용처 : 데이터 반환, 매핑처리, 컬렉션 조작
5. Predicate
- '하나의 매개변수'를 받아서 특정 조건을 검사 후 true/false 반환
- 사용처 : 필터링, 조건검사, 유효성 검사
  - 특히 Predicate의 경우 true/false 반환값을 가지고 저건문 돌릴시 많이 사용
6. 함수형 인터페이스 조합
- java 8에서는 함수형 인터페이스 끼리 조합이 가능

```java
import java.util.function.Predicate;

public static void main(String[] args) {
    //메서드1
    Predicate<String> startsWithA = str -> str.startsWith("A"); //.startsWith()는 String 클래스에 있는 메서드
    //메서드2
    Predicate<String> endsWithX = str -> str.endsWith("x");

    // and()로 두조건 결합
    Predicate<String> startsWithAAndendsWithX = startsWithA.and(endsWithX);

    System.out.println(startsWithAAndendsWithX.test("Alex"));
}
```
# 시험 관련 안내
* 09시~ 18시 시험
- 9시 시험안내 -> 09시 10분~ 17:500
- 객체지향 프로그래밍 언어
1. 프로그래밍 언어 활용
2. 프로그래밍 언어 응용

## 프로그래밍 언어 활용
20문제 서답형

.md 파일 상에서 명시적으로 정리되지 않은 부분이 2~3문제 정도 있음
구글에서 검색 가능.
Github, 코드 자체정리 노트 확인 등 전부 가능
ctrl + shift + f 파일전체에서 검색가능
- 특정 문제가 md파일에 없다는것을 확신 할 경우 구글에서 검색해서 알아봐야 할 수 있음.

ex) 특정 메서드 이름을 적으시오
    특정 자료형을 적으시오.
    키워드를 적으시오. etc.. < 1시간도안걸릴 걸로 예상

## 프로그래밍 언어 응용
- 코딩 테스트
  - json(21) / Singleton(18) / Builder(21) / Collection(20) 관련 코드 직접작성
  - 20/20/30/30 배분 부분점수 있음
  - 저장만하는것이아닌, 제출까지해야함 (제출시 수정불가능)
  - 60정 미만 -> 재시험대상자 1/2과목 독립시행